Background: Nonparametric statistical inference
-----------------------------------------------

A common task when analyzing networks is to characterize their
structures in simple terms, often by dividing the nodes into modules or
`"communities" <https://en.wikipedia.org/wiki/Community_structure>`__.

A principled approach to perform this task is to formulate `generative
models <https://en.wikipedia.org/wiki/Generative_model>`_ that include
the idea of "modules" in their descriptions, which then can be detected
by `inferring <https://en.wikipedia.org/wiki/Statistical_inference>`_
the model parameters from data. More precisely, given the partition
:math:`\boldsymbol b = \{b_i\}` of the network into :math:`B` groups,
where :math:`b_i\in[0,B-1]` is the group membership of node :math:`i`,
we define a model that generates a network :math:`\boldsymbol G` with a
probability

.. math::
   :label: model-likelihood

   P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)

where :math:`\boldsymbol\theta` are additional model parameters that
control how the node partition affects the structure of the
network. Therefore, if we observe a network :math:`\boldsymbol G`, the
likelihood that it was generated by a given partition :math:`\boldsymbol
b` is obtained via the `Bayesian
<https://en.wikipedia.org/wiki/Bayesian_inference>`_ posterior probability

.. math::
   :label: model-posterior-sum

   P(\boldsymbol b | \boldsymbol G) = \frac{\sum_{\boldsymbol\theta}P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)P(\boldsymbol\theta, \boldsymbol b)}{P(\boldsymbol G)}

where :math:`P(\boldsymbol\theta, \boldsymbol b)` is the `prior
probability <https://en.wikipedia.org/wiki/Prior_probability>`_ of the
model parameters, and

.. math::
   :label: model-evidence

   P(\boldsymbol G) = \sum_{\boldsymbol\theta,\boldsymbol b}P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)P(\boldsymbol\theta, \boldsymbol b)

is called the `evidence`, and corresponds to the total probability of
the data summed over all model parameters. The particular types of model
that will be considered here have "hard constraints", such that there is
only one choice for the remaining parameters :math:`\boldsymbol\theta`
that is compatible with the generated network, such that
Eq. :eq:`model-posterior-sum` simplifies to

.. math::
   :label: model-posterior

   P(\boldsymbol b | \boldsymbol G) = \frac{P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)P(\boldsymbol\theta, \boldsymbol b)}{P(\boldsymbol G)}

with :math:`\boldsymbol\theta` above being the only choice compatible with
:math:`\boldsymbol G` and :math:`\boldsymbol b`. The inference procedures considered
here will consist in either finding a network partition that maximizes
Eq. :eq:`model-posterior`, or sampling different partitions according
its posterior probability.

As we will show below, this approach also enables the comparison of
`different` models according to statistical evidence (a.k.a. `model
selection`).

Minimum description length (MDL)
++++++++++++++++++++++++++++++++

We note that Eq. :eq:`model-posterior` can be written as

.. math::

   P(\boldsymbol b | \boldsymbol G) = \frac{\exp(-\Sigma)}{P(\boldsymbol G)}

where

.. math::
   :label: model-dl

   \Sigma = -\ln P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b) - \ln P(\boldsymbol\theta, \boldsymbol b)

is called the **description length** of the network :math:`\boldsymbol
G`. It measures the amount of `information
<https://en.wikipedia.org/wiki/Information_theory>`_ required to
describe the data, if we `encode
<https://en.wikipedia.org/wiki/Entropy_encoding>`_ it using the
particular parametrization of the generative model given by
:math:`\boldsymbol\theta` and :math:`\boldsymbol b`, as well as the
parameters themselves. Therefore, if we choose to maximize the posterior
distribution of Eq. :eq:`model-posterior` it will be fully equivalent to
the so-called `minimum description length
<https://en.wikipedia.org/wiki/Minimum_description_length>`_
method. This approach corresponds to an implementation of `Occam's razor
<https://en.wikipedia.org/wiki/Occam%27s_razor>`_, where the `simplest`
model is selected, among all possibilities with the same explanatory
power. The selection is based on the statistical evidence available, and
therefore will not `overfit
<https://en.wikipedia.org/wiki/Overfitting>`_, i.e. mistake stochastic
fluctuations for actual structure. In particular this means that we will
not find modules in networks if they could have arisen simply because of
stochastic fluctuations, as they do in fully random graphs
[guimera-modularity-2004]_.

The stochastic block model (SBM)
--------------------------------

The `stochastic block model
<https://en.wikipedia.org/wiki/Stochastic_block_model>`_ is arguably
the simplest generative process based on the notion of groups of
nodes [holland-stochastic-1983]_. The `microcanonical
<https://en.wikipedia.org/wiki/Microcanonical_ensemble>`_ formulation
[peixoto-nonparametric-2017]_ of the basic or "traditional" version takes
as parameters the partition of the nodes into groups
:math:`\boldsymbol b` and a :math:`B\times B` matrix of edge counts
:math:`\boldsymbol e`, where :math:`e_{rs}` is the number of edges
between groups :math:`r` and :math:`s`. Given these constraints, the
edges are then placed randomly. Hence, nodes that belong to the same
group possess the same probability of being connected with other
nodes of the network.

An example of a possible parametrization is given in the following
figure.

.. testcode:: sbm-example
   :hide:

   import os
   try:
      os.chdir("demos/inference")
   except FileNotFoundError:
       pass

   g = gt.load_graph("blockmodel-example.gt.gz")
   gt.graph_draw(g, pos=g.vp.pos, vertex_size=10, vertex_fill_color=g.vp.bo,
                 vertex_color="#333333",
                 edge_gradient=g.new_ep("vector<double>", val=[0]),
                 output="sbm-example.svg")

   ers = g.gp.w

   from pylab import *
   figure()
   matshow(log(ers))
   xlabel("Group $r$")
   ylabel("Group $s$")
   gca().xaxis.set_label_position("top") 
   savefig("sbm-example-ers.svg")

.. table::
    :class: figure

    +----------------------------------+------------------------------+
    |.. figure:: sbm-example-ers.svg   |.. figure:: sbm-example.svg   |
    |   :width: 300px                  |   :width: 300px              |
    |   :align: center                 |   :align: center             |
    |                                  |                              |
    |   Matrix of edge counts          |   Generated network.         |
    |   :math:`\boldsymbol e` between  |                              |
    |   groups.                        |                              |
    +----------------------------------+------------------------------+

.. note::

   We emphasize that no constraints are imposed on what `kind` of
   modular structure is allowed, as the matrix of edge counts :math:`e`
   is unconstrained. Hence, we can detect the putatively typical pattern
   of `"community structure"
   <https://en.wikipedia.org/wiki/Community_structure>`_, i.e. when
   nodes are connected mostly to other nodes of the same group, if it
   happens to be the most likely network description, but we can also
   detect a large multiplicity of other patterns, such as `bipartiteness
   <https://en.wikipedia.org/wiki/Bipartite_graph>`_, core-periphery,
   and many others, all under the same inference framework.


Although quite general, the traditional model assumes that the edges are
placed randomly inside each group, and because of this the nodes that
belong to the same group tend to have very similar degrees. As it turns
out, this is often a poor model for many networks, which possess highly
heterogeneous degree distributions. A better model for such networks is
called the `degree-corrected` stochastic block model
[karrer-stochastic-2011]_, and it is defined just like the traditional
model, with the addition of the degree sequence :math:`\boldsymbol k =
\{k_i\}` of the graph as an additional set of parameters (assuming again
a microcanonical formulation [peixoto-nonparametric-2017]_).


The nested stochastic block model
+++++++++++++++++++++++++++++++++

The regular SBM has a drawback when applied to large networks. Namely,
it cannot be used to find relatively small groups, as the maximum number
of groups that can be found scales as
:math:`B_{\text{max}}=O(\sqrt{N})`, where :math:`N` is the number of
nodes in the network, if Bayesian inference is performed
[peixoto-parsimonious-2013]_. In order to circumvent this, we need to
replace the noninformative priors used by a hierarchy of priors and
hyperpriors, which amounts to a `nested SBM`, where the groups
themselves are clustered into groups, and the matrix :math:`e` of edge
counts are generated from another SBM, and so on recursively
[peixoto-hierarchical-2014]_, as illustrated below.

.. figure:: nested-diagram.*
   :width: 400px
   :align: center

   Example of a nested SBM with three levels.

With this model, the maximum number of groups that can be inferred
scales as :math:`B_{\text{max}}=O(N/\log(N))`. In addition to being able
to find small groups in large networks, this model also provides a
multilevel hierarchical description of the network. With such a
description, we can uncover structural patterns at multiple scales,
representing different levels of coarse-graining.
